-- ed_sim_mem.vhd

-- Generated using ACDS version 22.2 94

library IEEE;
library altera_emif_mem_model_191;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity ed_sim_mem is
	port (
		mem_ck      : in    std_logic_vector(0 downto 0)  := (others => '0'); -- mem.mem_ck,      CK clock
		mem_ck_n    : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_ck_n,    CK clock (negative leg)
		mem_a       : in    std_logic_vector(16 downto 0) := (others => '0'); --    .mem_a,       Address
		mem_act_n   : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_act_n,   Activation command
		mem_ba      : in    std_logic_vector(1 downto 0)  := (others => '0'); --    .mem_ba,      Bank address
		mem_bg      : in    std_logic_vector(1 downto 0)  := (others => '0'); --    .mem_bg,      Bank group
		mem_cke     : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_cke,     Clock enable
		mem_cs_n    : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_cs_n,    Chip select
		mem_odt     : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_odt,     On-die termination
		mem_reset_n : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_reset_n, Asynchronous reset
		mem_par     : in    std_logic_vector(0 downto 0)  := (others => '0'); --    .mem_par,     Command and address parity
		mem_alert_n : out   std_logic_vector(0 downto 0);                     --    .mem_alert_n, Alert flag
		mem_dqs     : inout std_logic_vector(8 downto 0)  := (others => '0'); --    .mem_dqs,     Data strobe
		mem_dqs_n   : inout std_logic_vector(8 downto 0)  := (others => '0'); --    .mem_dqs_n,   Data strobe (negative leg)
		mem_dq      : inout std_logic_vector(71 downto 0) := (others => '0'); --    .mem_dq,      Read/write data
		mem_dbi_n   : inout std_logic_vector(8 downto 0)  := (others => '0')  --    .mem_dbi_n,   Acts as either the data bus inversion pin, or the data mask pin, depending on configuration.
	);
end entity ed_sim_mem;

architecture rtl of ed_sim_mem is
	component ed_sim_mem_altera_emif_mem_model_191_bu2wx3i_cmp is
		port (
			mem_ck      : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_ck
			mem_ck_n    : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_ck_n
			mem_a       : in    std_logic_vector(16 downto 0) := (others => 'X'); -- mem_a
			mem_act_n   : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_act_n
			mem_ba      : in    std_logic_vector(1 downto 0)  := (others => 'X'); -- mem_ba
			mem_bg      : in    std_logic_vector(1 downto 0)  := (others => 'X'); -- mem_bg
			mem_cke     : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_cke
			mem_cs_n    : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_cs_n
			mem_odt     : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_odt
			mem_reset_n : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_reset_n
			mem_par     : in    std_logic_vector(0 downto 0)  := (others => 'X'); -- mem_par
			mem_alert_n : out   std_logic_vector(0 downto 0);                     -- mem_alert_n
			mem_dqs     : inout std_logic_vector(8 downto 0)  := (others => 'X'); -- mem_dqs
			mem_dqs_n   : inout std_logic_vector(8 downto 0)  := (others => 'X'); -- mem_dqs_n
			mem_dq      : inout std_logic_vector(71 downto 0) := (others => 'X'); -- mem_dq
			mem_dbi_n   : inout std_logic_vector(8 downto 0)  := (others => 'X')  -- mem_dbi_n
		);
	end component ed_sim_mem_altera_emif_mem_model_191_bu2wx3i_cmp;

	for mem : ed_sim_mem_altera_emif_mem_model_191_bu2wx3i_cmp
		use entity altera_emif_mem_model_191.ed_sim_mem_altera_emif_mem_model_191_bu2wx3i;
begin

	mem : component ed_sim_mem_altera_emif_mem_model_191_bu2wx3i_cmp
		port map (
			mem_ck      => mem_ck,      -- mem.mem_ck
			mem_ck_n    => mem_ck_n,    --    .mem_ck_n
			mem_a       => mem_a,       --    .mem_a
			mem_act_n   => mem_act_n,   --    .mem_act_n
			mem_ba      => mem_ba,      --    .mem_ba
			mem_bg      => mem_bg,      --    .mem_bg
			mem_cke     => mem_cke,     --    .mem_cke
			mem_cs_n    => mem_cs_n,    --    .mem_cs_n
			mem_odt     => mem_odt,     --    .mem_odt
			mem_reset_n => mem_reset_n, --    .mem_reset_n
			mem_par     => mem_par,     --    .mem_par
			mem_alert_n => mem_alert_n, --    .mem_alert_n
			mem_dqs     => mem_dqs,     --    .mem_dqs
			mem_dqs_n   => mem_dqs_n,   --    .mem_dqs_n
			mem_dq      => mem_dq,      --    .mem_dq
			mem_dbi_n   => mem_dbi_n    --    .mem_dbi_n
		);

end architecture rtl; -- of ed_sim_mem
